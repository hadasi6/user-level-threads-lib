omer.miranda, hadas6
Omer Miranda (315408997), Hadas Elezra (207848615)
EX: 2

FILES:
uthreads.cpp -- user level threads management library
Thread.cpp -- a cpp class representing a thread
Thread.h -- header file for Thread.cpp

REMARKS:

ANSWERS:

Q1:
a) sigsetjmp() is used to save the current state of a program's execution environment
(including the stack context, signal mask, and program counter) to a buffer.
if it returns 0 it means that the function was just used to save the state and else it means
that it returned after a jump from some other context.
the first argument is a buffer for saving the environment and the second is whether or not to save the signal
masking.
siglongjmp() is used to restore the saved state of the program's execution from the buffer set by sigsetjmp().
This causes the program to jump back to the point where sigsetjmp() was called, as if the function had just
returned from a setjmp call.
the first argument is the environment to jump into and the second is the return val that setjump will return
(as in the documentation 0 cant be the ret val and if the user does use it the method will change it to 1).
b) if the second argument of sigsetjmp != 0 than the masking will be saved. on later jump back to it the masking
will be restored. if it was set to 0 than the jump will not restore the masking and the masking of the target thread
will the the same as the masking of the source thread.

Q2:
user level threads are a reasonable option of a multitasking process that mostly does computational operations via the
processor and less likely to use system calls and rise the operation system. in this case runtime can be saved because
of the less demanding context switch overhead compared to a kernel level switch and this can be especially useful for
programs where the real running time is very important.

Q3:
advantages: there is a bigger separation between the environments (compared to kernel threads) of the different processes
and so for example if one process crushes it is less likely to affect the others and so some error in one tab will
probably not affect the user when he uses some other tabs.
another advantage can be security as the separation between the process makes it harder to share data between processes
(related to threads) which is better for example when using a bank website on one tab and some social network on another.

disadvantage: because of the separation the memory consumption of the different tabs will be higher when implemented as
processes compared to threads and so the browser will be more demanding.

Q4:
first when we type the kill command the keyboard send interrupts .
the shell handles the interrupts and after processing the input (kill command) it sends a SIGTERM signal to the target
process - the OS takes control and delivers the signal to the target process. this signal default handler cannot be
changed and so when handling this signal the target process must terminate itself.

Q5:
virtual time of a process or a thread is the time the thread/process was running.
the real time is the actual time passed in the real world. the real time will always be equal or bigger than the
virtual time of a process/thread as the process might not be running the entire duration (because of overheads and
switches).
one example for using real time is a timer application. when a user uses a timer what matters to him is the amount
of time passed in the real world and not the virtual time.
one example for the use of virtual time is a thead library as we a going to implement here. what matters when timing
switching between threads is the time they run - the virtual time. if for example a system call blocked the whole
process than the real time of the current thread will still count and its turn could pass before it could do anything
which is undesired and using virtual time will solve this issue.